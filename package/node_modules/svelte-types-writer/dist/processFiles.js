"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processText = exports.processFiles = void 0;
const svelte2tsx_1 = __importDefault(require("svelte2tsx"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const glob_1 = require("glob");
const readFiles = (files, workdir) => {
    const currpath = path_1.default.resolve("./");
    const res = [];
    for (let file of files) {
        const foundFiles = glob_1.glob.sync(file);
        if (foundFiles.length === 0) {
            console.log("found no files under: " + file);
        }
        for (let foundfile of foundFiles) {
            try {
                const text = fs_extra_1.default.readFileSync(foundfile, { encoding: "utf-8" });
                const name = path_1.default.basename(foundfile, path_1.default.extname(foundfile));
                const dir = path_1.default.relative(currpath, path_1.default.dirname(foundfile));
                if (!dir.startsWith("..")) {
                    // files outside the root are put to root
                    const targetpath = path_1.default.join(workdir, dir);
                    if (!fs_extra_1.default.existsSync(targetpath)) {
                        fs_extra_1.default.mkdirSync(targetpath, { recursive: true });
                    }
                    ;
                }
                res.push({ text, name, dir, svelte: path_1.default.extname(foundfile).toLowerCase() === ".svelte" });
            }
            catch (e) {
                console.log("Could not process " + foundfile);
                console.log(e);
            }
        }
    }
    return res;
};
exports.processFiles = (files, libs, outfolder, debug = false, nojs = false, override = false) => {
    if (files.length === 0) {
        return "no files";
    }
    // write received tsx file and extra type declarations
    const workdir = fs_extra_1.default.mkdtempSync("./");
    const f = readFiles(files, workdir);
    const texts = exports.processText(f, libs, workdir, debug, nojs);
    if (outfolder !== "none") {
        if (!fs_extra_1.default.existsSync(outfolder)) {
            fs_extra_1.default.mkdirSync(outfolder, { recursive: true });
        }
    }
    const currpath = path_1.default.resolve("./");
    texts.then(v => {
        v.forEach(w => {
            if (outfolder === "none") {
                if (override || !fs_extra_1.default.existsSync(w.name)) {
                    console.log("Write file: " + w.name);
                    fs_extra_1.default.writeFileSync(w.name, w.text);
                }
                else {
                    console.log("file '" + w.name + "' already exists. See option --override.");
                }
            }
            else {
                const full = path_1.default.relative(currpath, w.name);
                const file = path_1.default.join(outfolder, full);
                const dir = path_1.default.dirname(file);
                if (!fs_extra_1.default.existsSync(dir)) {
                    fs_extra_1.default.mkdirSync(dir);
                }
                if (override || !fs_extra_1.default.existsSync(file)) {
                    console.log("Write file: " + file);
                    fs_extra_1.default.writeFileSync(file, w.text);
                }
                else {
                    console.log("file '" + file + "' already exists. See option --override.");
                }
            }
        });
    });
};
exports.processText = (files, libs, workdir, debug = false, nojs = false) => {
    // process the .svelte file with svelte2tsx, but only if they have .svelte extension
    const tsx = files.map(v => {
        if (!v.svelte) {
            return Object.assign({ svelte: false }, v);
        }
        return {
            text: svelte2tsx_1.default(v.text, {
                filename: v.name, strictMode: true, isTsFile: true
            }).code, name: v.name, dir: v.dir, svelte: true
        };
    });
    const jswrapper = nojs ? [] :
        tsx.filter(v => v.svelte).map(v => {
            let filename = path_1.default.join(v.dir, v.name);
            //fs.writeFileSync(filename + ".js", `import `+ v.name + ` from './` + v.name + `.svelte';\nexport default `+v.name+`;\n `);
            return { name: filename + ".js", text: `import ` + v.name + ` from './` + v.name + `.svelte';\nexport default ` + v.name + `;\n ` };
        });
    const filenames = tsx.map(v => {
        let filename = path_1.default.join(workdir, v.dir, v.name);
        if (v.dir.startsWith("..")) {
            filename = path_1.default.join(workdir, v.name);
        }
        fs_extra_1.default.writeFileSync(filename + ".tsx", v.svelte ? preprocessTsx(v.text, v.name) : v.text);
        return { filename, from: path_1.default.join(v.dir, v.name) };
    });
    const currpath = path_1.default.resolve("./");
    libs.forEach(v => {
        const foundFiles = glob_1.glob.sync(v);
        for (let file of foundFiles) {
            const dir = path_1.default.relative(currpath, path_1.default.dirname(file));
            if (!dir.startsWith("..")) {
                // files outside the root are put to root
                const targetpath = path_1.default.join(workdir, dir);
                const name = path_1.default.basename(file);
                if (!fs_extra_1.default.existsSync(targetpath)) {
                    fs_extra_1.default.mkdirSync(targetpath, { recursive: true });
                }
                ;
                fs_extra_1.default.copyFileSync(file, path_1.default.join(targetpath, name));
            }
        }
    });
    // compile tsx file with tsc but only further process declaration file
    const ret = new Promise((resolve, reject) => {
        let shims = require.resolve("svelte2tsx/svelte-shims.d.ts");
        /* this is probably not needed anymore */
        if (!fs_extra_1.default.existsSync(shims)) {
            shims = "./node_modules/svelte2tsx/svelte-shims.d.ts";
            if (!fs_extra_1.default.existsSync(shims)) {
                shims = "./node_modules/svelte-type-writer/node_modules/svelte2tsx/svelte-shims.d.ts";
            }
        }
        const tscOptions = ["--emitDeclarationOnly", "--declaration"]
            .concat(filenames.map(v => v.filename + ".tsx"))
            //.concat(["extratypes.d.ts"])
            .concat(libs.map(v => path_1.default.join(workdir, v)))
            .concat([shims]);
        if (debug) {
            console.log(tscOptions);
        }
        ;
        const sp = child_process_1.spawn("tsc", tscOptions, { cwd: "./" });
        const cont = () => {
            const res = jswrapper;
            for (let file of filenames) {
                const dtsfile = file.filename + ".d.ts";
                if (!fs_extra_1.default.existsSync(dtsfile)) {
                    console.log(dtsfile + ": d.ts file not found");
                }
                try {
                    // read in newly created d.ts file
                    const types = fs_extra_1.default.readFileSync(dtsfile, { encoding: "utf-8" });
                    // restructure file
                    const adjtypes = processDTS(types);
                    // clean up
                    res.push({ text: adjtypes, name: file.from + ".d.ts" });
                }
                catch (e) {
                    console.log(e);
                }
            }
            if (!debug) {
                fs_extra_1.default.removeSync(workdir);
            }
            resolve(res);
        };
        sp.on("close", cont);
    });
    return ret;
};
const processDTS = (file) => {
    const file1 = file.replace(/: false;/g, ": boolean;").replace(/: true;/g, ": boolean;");
    if (file1.includes("SvelteAllProps")) {
        const s = file1.split("}");
        return s[0] + ", SvelteAllProps }" + s.slice(1).join("}");
    }
    // false and true to boolean
    return file1;
};
const preprocessTsx = (text, name) => {
    const a = text.split("export default class");
    const b = a[1].split("createSvelte2TsxComponent");
    const c1 = b[1].split("{");
    const c2 = "{" + c1.slice(1).join("{");
    // fix if on:* is used;
    const maintsx = a[0].replace(/on\*=/g, "onany=");
    const main = maintsx +
        "export default class " + name + " extends SvelteComponentTyped<" + name + "Props," + name + "Events," + name + "Slots>" + c2 + ";\n" +
        "const r = " + c1[0] + "();\n" +
        "const _" + name + "Props = r.props;\n" +
        "const _" + name + "Events = r.events;\n" +
        "const _" + name + "Slots = r.slots;\n" +
        "export type " + name + "Props = typeof _" + name + "Props;\n" +
        "export type " + name + "Events = typeof _" + name + "Events;\n" +
        "export type " + name + "Slots = typeof _" + name + "Slots;\n";
    return "import {SvelteComponentTyped} from 'svelte'\n" + main;
};
//# sourceMappingURL=processFiles.js.map